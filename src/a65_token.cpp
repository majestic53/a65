/**
 * A65
 * Copyright (C) 2018 David Jolly
 *
 * A65 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * A65 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <sstream>
#include "../inc/a65_token.h"
#include "../inc/a65_utility.h"

#define A65_TOKEN_MAX A65_TOKEN_SYMBOL

static const std::string A65_TOKEN_STR[] = {
	"Begin", "Command", "Constant", "Directive", "End", "Identifier", "Label", "Literal",
	"Macro", "Pragma", "Register", "Scalar", "Symbol",
	};

#define A65_TOKEN_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_STR[_TYPE_]))

#define A65_TOKEN_COMMAND_MAX A65_TOKEN_COMMAND_WAI

static const std::string A65_TOKEN_COMMAND_STR[] = {
	"adc", "and", "asl", "bbr0", "bbr1", "bbr2", "bbr3", "bbr4", "bbr5", "bbr6", "bbr7",
	"bbs0", "bbs1", "bbs2", "bbs3", "bbs4", "bbs5", "bbs6", "bbs7", "bcc", "bcs", "beq",
	"bit", "bmi", "bne", "bpl", "bra", "brk", "bvc", "bvs", "clc", "cld", "cli", "clv",
	"cmp", "cpx", "cpy", "dec", "dex", "dey", "eor", "inc", "inx", "iny", "jmp", "jsr",
	"lda", "ldx", "ldy", "lsr", "nop", "ora", "pha", "php", "phx", "phy", "pla", "plp", "plx", "ply",
	"rmb0", "rmb1", "rmb2", "rmb3", "rmb4", "rmb5", "rmb6", "rmb7", "rol", "ror", "rti", "rts",
	"sbc", "sec", "sed", "sei", "smb0", "smb1", "smb2", "smb3", "smb4", "smb5", "smb6", "smb7",
	"sta", "stp", "stx", "sty", "stz", "tax", "tay", "trb", "tsb", "tsx", "txa", "txs", "tya", "wai",
	};

#define A65_TOKEN_COMMAND_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_COMMAND_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_COMMAND_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_COMMAND_MAP = {
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_ADC), A65_TOKEN_COMMAND_ADC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_AND), A65_TOKEN_COMMAND_AND),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_ASL), A65_TOKEN_COMMAND_ASL),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR0), A65_TOKEN_COMMAND_BBR0),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR1), A65_TOKEN_COMMAND_BBR1),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR2), A65_TOKEN_COMMAND_BBR2),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR3), A65_TOKEN_COMMAND_BBR3),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR4), A65_TOKEN_COMMAND_BBR4),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR5), A65_TOKEN_COMMAND_BBR5),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR6), A65_TOKEN_COMMAND_BBR6),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBR7), A65_TOKEN_COMMAND_BBR7),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS0), A65_TOKEN_COMMAND_BBS0),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS1), A65_TOKEN_COMMAND_BBS1),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS2), A65_TOKEN_COMMAND_BBS2),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS3), A65_TOKEN_COMMAND_BBS3),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS4), A65_TOKEN_COMMAND_BBS4),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS5), A65_TOKEN_COMMAND_BBS5),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS6), A65_TOKEN_COMMAND_BBS6),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BBS7), A65_TOKEN_COMMAND_BBS7),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BCC), A65_TOKEN_COMMAND_BCC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BCS), A65_TOKEN_COMMAND_BCS),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BEQ), A65_TOKEN_COMMAND_BEQ),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BIT), A65_TOKEN_COMMAND_BIT),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BMI), A65_TOKEN_COMMAND_BMI),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BNE), A65_TOKEN_COMMAND_BNE),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BPL), A65_TOKEN_COMMAND_BPL),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BRA), A65_TOKEN_COMMAND_BRA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BRK), A65_TOKEN_COMMAND_BRK),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BVC), A65_TOKEN_COMMAND_BVC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_BVS), A65_TOKEN_COMMAND_BVS),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CLC), A65_TOKEN_COMMAND_CLC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CLD), A65_TOKEN_COMMAND_CLD),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CLI), A65_TOKEN_COMMAND_CLI),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CLV), A65_TOKEN_COMMAND_CLV),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CMP), A65_TOKEN_COMMAND_CMP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CPX), A65_TOKEN_COMMAND_CPX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_CPY), A65_TOKEN_COMMAND_CPY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_DEC), A65_TOKEN_COMMAND_DEC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_DEX), A65_TOKEN_COMMAND_DEX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_DEY), A65_TOKEN_COMMAND_DEY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_EOR), A65_TOKEN_COMMAND_EOR),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_INC), A65_TOKEN_COMMAND_INC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_INX), A65_TOKEN_COMMAND_INX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_INY), A65_TOKEN_COMMAND_INY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_JMP), A65_TOKEN_COMMAND_JMP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_JSR), A65_TOKEN_COMMAND_JSR),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_LDA), A65_TOKEN_COMMAND_LDA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_LDX), A65_TOKEN_COMMAND_LDX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_LDY), A65_TOKEN_COMMAND_LDY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_LSR), A65_TOKEN_COMMAND_LSR),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_NOP), A65_TOKEN_COMMAND_NOP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_ORA), A65_TOKEN_COMMAND_ORA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PHA), A65_TOKEN_COMMAND_PHA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PHP), A65_TOKEN_COMMAND_PHP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PHX), A65_TOKEN_COMMAND_PHX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PHY), A65_TOKEN_COMMAND_PHY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PLA), A65_TOKEN_COMMAND_PLA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PLP), A65_TOKEN_COMMAND_PLP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PLX), A65_TOKEN_COMMAND_PLX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_PLY), A65_TOKEN_COMMAND_PLY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB0), A65_TOKEN_COMMAND_RMB0),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB1), A65_TOKEN_COMMAND_RMB1),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB2), A65_TOKEN_COMMAND_RMB2),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB3), A65_TOKEN_COMMAND_RMB3),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB4), A65_TOKEN_COMMAND_RMB4),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB5), A65_TOKEN_COMMAND_RMB5),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB6), A65_TOKEN_COMMAND_RMB6),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RMB7), A65_TOKEN_COMMAND_RMB7),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_ROL), A65_TOKEN_COMMAND_ROL),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_ROR), A65_TOKEN_COMMAND_ROR),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RTI), A65_TOKEN_COMMAND_RTI),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_RTS), A65_TOKEN_COMMAND_RTS),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB), A65_TOKEN_COMMAND_SMB),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SEC), A65_TOKEN_COMMAND_SEC),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SED), A65_TOKEN_COMMAND_SED),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SEI), A65_TOKEN_COMMAND_SEI),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB0), A65_TOKEN_COMMAND_SMB0),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB1), A65_TOKEN_COMMAND_SMB1),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB2), A65_TOKEN_COMMAND_SMB2),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB3), A65_TOKEN_COMMAND_SMB3),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB4), A65_TOKEN_COMMAND_SMB4),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB5), A65_TOKEN_COMMAND_SMB5),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB6), A65_TOKEN_COMMAND_SMB6),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_SMB7), A65_TOKEN_COMMAND_SMB7),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_STA), A65_TOKEN_COMMAND_STA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_STP), A65_TOKEN_COMMAND_STP),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_STX), A65_TOKEN_COMMAND_STX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_STY), A65_TOKEN_COMMAND_STY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_STZ), A65_TOKEN_COMMAND_STZ),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TAX), A65_TOKEN_COMMAND_TAX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TAY), A65_TOKEN_COMMAND_TAY),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TRB), A65_TOKEN_COMMAND_TRB),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TSB), A65_TOKEN_COMMAND_TSB),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TSX), A65_TOKEN_COMMAND_TSX),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TXA), A65_TOKEN_COMMAND_TXA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TXS), A65_TOKEN_COMMAND_TXS),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_TYA), A65_TOKEN_COMMAND_TYA),
	std::make_pair(A65_TOKEN_COMMAND_STRING(A65_TOKEN_COMMAND_WAI), A65_TOKEN_COMMAND_WAI),
	};

#define A65_TOKEN_COMMAND_ID(_STRING__) \
	A65_TOKEN_COMMAND_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_COMMAND(_STRING_) \
	(A65_TOKEN_COMMAND_MAP.find(_STRING_) != A65_TOKEN_COMMAND_MAP.end())

#define A65_TOKEN_COMMAND_MODE_MAX A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDIRECT_INDEX

static const std::string A65_TOKEN_COMMAND_MODE_STR[] = {
	"abs", "(abs, x)", "abs, x", "abs, y", "(abs)", "acc", "imm", "imp", "rel", "zp", "(zp, x)",
	"zp, x", "zp, y", "(zp)", "(zp), y",
	};

#define A65_TOKEN_COMMAND_MODE_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_COMMAND_MODE_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_COMMAND_MODE_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_COMMAND_MODE_MAP = {
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ABSOLUTE), A65_TOKEN_COMMAND_MODE_ABSOLUTE),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_INDIRECT), A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_INDIRECT),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_X), A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_X),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_Y), A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDEX_Y),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDIRECT), A65_TOKEN_COMMAND_MODE_ABSOLUTE_INDIRECT),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ACCUMULATOR), A65_TOKEN_COMMAND_MODE_ACCUMULATOR),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_IMMEDIATE), A65_TOKEN_COMMAND_MODE_IMMEDIATE),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_IMPLIED), A65_TOKEN_COMMAND_MODE_IMPLIED),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_RELATIVE), A65_TOKEN_COMMAND_MODE_RELATIVE),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE), A65_TOKEN_COMMAND_MODE_ZEROPAGE),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_INDIRECT), A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_INDIRECT),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_X), A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_X),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_Y), A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDEX_Y),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDIRECT), A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDIRECT),
	std::make_pair(A65_TOKEN_COMMAND_MODE_STRING(A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDIRECT_INDEX), A65_TOKEN_COMMAND_MODE_ZEROPAGE_INDIRECT_INDEX),
	};

#define A65_TOKEN_COMMAND_MODE_ID(_STRING__) \
	A65_TOKEN_COMMAND_MODE_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_COMMAND_MODE(_STRING_) \
	(A65_TOKEN_COMMAND_MODE_MAP.find(_STRING_) != A65_TOKEN_COMMAND_MODE_MAP.end())

#define A65_TOKEN_CONSTANT_MAX A65_TOKEN_CONSTANT_TRUE

static const std::string A65_TOKEN_CONSTANT_STR[] = {
	"false", "null", "true",
	};

#define A65_TOKEN_CONSTANT_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_CONSTANT_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_CONSTANT_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_CONSTANT_MAP = {
	std::make_pair(A65_TOKEN_CONSTANT_STRING(A65_TOKEN_CONSTANT_FALSE), A65_TOKEN_CONSTANT_FALSE),
	std::make_pair(A65_TOKEN_CONSTANT_STRING(A65_TOKEN_CONSTANT_NULL), A65_TOKEN_CONSTANT_NULL),
	std::make_pair(A65_TOKEN_CONSTANT_STRING(A65_TOKEN_CONSTANT_TRUE), A65_TOKEN_CONSTANT_TRUE),
	};

#define A65_TOKEN_CONSTANT_ID(_STRING__) \
	A65_TOKEN_CONSTANT_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_CONSTANT(_STRING_) \
	(A65_TOKEN_CONSTANT_MAP.find(_STRING_) != A65_TOKEN_CONSTANT_MAP.end())

#define A65_TOKEN_DIRECTIVE_MAX A65_TOKEN_DIRECTIVE_UNDEFINE

static const std::string A65_TOKEN_DIRECTIVE_STR[] = {
	".db", ".dw", ".def", ".else", ".elseif", ".endif", ".if", ".ifdef", ".org", ".res", ".undef",
	};

#define A65_TOKEN_DIRECTIVE_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_DIRECTIVE_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_DIRECTIVE_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_DIRECTIVE_MAP = {
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_DATA_BYTE), A65_TOKEN_DIRECTIVE_DATA_BYTE),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_DATA_WORD), A65_TOKEN_DIRECTIVE_DATA_WORD),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_DEFINE), A65_TOKEN_DIRECTIVE_DEFINE),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_ELSE), A65_TOKEN_DIRECTIVE_ELSE),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_ELSE_IF), A65_TOKEN_DIRECTIVE_ELSE_IF),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_END), A65_TOKEN_DIRECTIVE_END),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_IF), A65_TOKEN_DIRECTIVE_IF),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_IF_DEFINE), A65_TOKEN_DIRECTIVE_IF_DEFINE),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_ORIGIN), A65_TOKEN_DIRECTIVE_ORIGIN),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_RESERVE), A65_TOKEN_DIRECTIVE_RESERVE),
	std::make_pair(A65_TOKEN_DIRECTIVE_STRING(A65_TOKEN_DIRECTIVE_UNDEFINE), A65_TOKEN_DIRECTIVE_UNDEFINE),
	};

#define A65_TOKEN_DIRECTIVE_ID(_STRING__) \
	A65_TOKEN_DIRECTIVE_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_DIRECTIVE(_STRING_) \
	(A65_TOKEN_DIRECTIVE_MAP.find(_STRING_) != A65_TOKEN_DIRECTIVE_MAP.end())

#define A65_TOKEN_MACRO_MAX A65_TOKEN_MACRO_LOW

static const std::string A65_TOKEN_MACRO_STR[] = {
	"high", "low",
	};

#define A65_TOKEN_MACRO_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_MACRO_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_MACRO_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_MACRO_MAP = {
	std::make_pair(A65_TOKEN_MACRO_STRING(A65_TOKEN_MACRO_HIGH), A65_TOKEN_MACRO_HIGH),
	std::make_pair(A65_TOKEN_MACRO_STRING(A65_TOKEN_MACRO_LOW), A65_TOKEN_MACRO_LOW),
	};

#define A65_TOKEN_MACRO_ID(_STRING__) \
	A65_TOKEN_MACRO_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_MACRO(_STRING_) \
	(A65_TOKEN_MACRO_MAP.find(_STRING_) != A65_TOKEN_MACRO_MAP.end())

#define A65_TOKEN_PRAGMA_MAX A65_TOKEN_PRAGMA_INCLUDE_SOURCE

static const std::string A65_TOKEN_PRAGMA_STR[] = {
	"@incb", "@inc",
	};

#define A65_TOKEN_PRAGMA_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_PRAGMA_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_PRAGMA_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_PRAGMA_MAP = {
	std::make_pair(A65_TOKEN_PRAGMA_STRING(A65_TOKEN_PRAGMA_INCLUDE_BINARY), A65_TOKEN_PRAGMA_INCLUDE_BINARY),
	std::make_pair(A65_TOKEN_PRAGMA_STRING(A65_TOKEN_PRAGMA_INCLUDE_SOURCE), A65_TOKEN_PRAGMA_INCLUDE_SOURCE),
	};

#define A65_TOKEN_PRAGMA_ID(_STRING__) \
	A65_TOKEN_PRAGMA_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_PRAGMA(_STRING_) \
	(A65_TOKEN_PRAGMA_MAP.find(_STRING_) != A65_TOKEN_PRAGMA_MAP.end())

#define A65_TOKEN_REGISTER_MAX A65_TOKEN_REGISTER_INDEX_Y

static const std::string A65_TOKEN_REGISTER_STR[] = {
	"a", "x", "y",
	};

#define A65_TOKEN_REGISTER_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_REGISTER_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_REGISTER_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_REGISTER_MAP = {
	std::make_pair(A65_TOKEN_REGISTER_STRING(A65_TOKEN_REGISTER_ACCUMULATOR), A65_TOKEN_REGISTER_ACCUMULATOR),
	std::make_pair(A65_TOKEN_REGISTER_STRING(A65_TOKEN_REGISTER_INDEX_X), A65_TOKEN_REGISTER_INDEX_X),
	std::make_pair(A65_TOKEN_REGISTER_STRING(A65_TOKEN_REGISTER_INDEX_Y), A65_TOKEN_REGISTER_INDEX_Y),
	};

#define A65_TOKEN_REGISTER_ID(_STRING__) \
	A65_TOKEN_REGISTER_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_REGISTER(_STRING_) \
	(A65_TOKEN_REGISTER_MAP.find(_STRING_) != A65_TOKEN_REGISTER_MAP.end())

#define A65_TOKEN_SYMBOL_MAX A65_TOKEN_SYMBOL_UNARY_NOT

static const std::string A65_TOKEN_SYMBOL_STR[] = {
	"+", "/", "%", "*", "-", "&", "|", "^", "&&", "||", "==", ">", ">=", "<", "<=", "!=",
	"<<", ">>", "}", "{", "[", "]", "#", "(", ")", ",", "~", "!",
	};

#define A65_TOKEN_SYMBOL_STRING(_TYPE_) \
	(((_TYPE_) > A65_TOKEN_SYMBOL_MAX) ? A65_STRING_UNKNOWN : \
		A65_STRING_CHECK(A65_TOKEN_SYMBOL_STR[_TYPE_]))

static const std::map<std::string, int> A65_TOKEN_SYMBOL_MAP = {
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_ARITHMETIC_ADDITION), A65_TOKEN_SYMBOL_ARITHMETIC_ADDITION),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_ARITHMETIC_DIVIDE), A65_TOKEN_SYMBOL_ARITHMETIC_DIVIDE),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_ARITHMETIC_MODULUS), A65_TOKEN_SYMBOL_ARITHMETIC_MODULUS),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_ARITHMETIC_MULTIPLY), A65_TOKEN_SYMBOL_ARITHMETIC_MULTIPLY),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_ARITHMETIC_SUBTRACTION), A65_TOKEN_SYMBOL_ARITHMETIC_SUBTRACTION),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BINARY_AND), A65_TOKEN_SYMBOL_BINARY_AND),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BINARY_OR), A65_TOKEN_SYMBOL_BINARY_OR),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BINARY_XOR), A65_TOKEN_SYMBOL_BINARY_XOR),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_AND), A65_TOKEN_SYMBOL_LOGICAL_AND),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_OR), A65_TOKEN_SYMBOL_LOGICAL_OR),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_EQUALS), A65_TOKEN_SYMBOL_LOGICAL_EQUALS),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_GREATER_THAN), A65_TOKEN_SYMBOL_LOGICAL_GREATER_THAN),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_GREATER_THAN_EQUALS), A65_TOKEN_SYMBOL_LOGICAL_GREATER_THAN_EQUALS),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_LESS_THAN), A65_TOKEN_SYMBOL_LOGICAL_LESS_THAN),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_LESS_THAN_EQUALS), A65_TOKEN_SYMBOL_LOGICAL_LESS_THAN_EQUALS),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_NOT_EQUALS), A65_TOKEN_SYMBOL_LOGICAL_NOT_EQUALS),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_SHIFT_LEFT), A65_TOKEN_SYMBOL_LOGICAL_SHIFT_LEFT),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_LOGICAL_SHIFT_RIGHT), A65_TOKEN_SYMBOL_LOGICAL_SHIFT_RIGHT),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BRACE_CURLY_CLOSE), A65_TOKEN_SYMBOL_BRACE_CURLY_CLOSE),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BRACE_CURLY_OPEN), A65_TOKEN_SYMBOL_BRACE_CURLY_OPEN),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BRACE_SQUARE_CLOSE), A65_TOKEN_SYMBOL_BRACE_SQUARE_CLOSE),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_BRACE_SQUARE_OPEN), A65_TOKEN_SYMBOL_BRACE_SQUARE_OPEN),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_IMMEDIATE), A65_TOKEN_SYMBOL_IMMEDIATE),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_PARENTHESIS_CLOSE), A65_TOKEN_SYMBOL_PARENTHESIS_CLOSE),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_PARENTHESIS_OPEN), A65_TOKEN_SYMBOL_PARENTHESIS_OPEN),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_SEPERATOR), A65_TOKEN_SYMBOL_SEPERATOR),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_UNARY_NEGATION), A65_TOKEN_SYMBOL_UNARY_NEGATION),
	std::make_pair(A65_TOKEN_SYMBOL_STRING(A65_TOKEN_SYMBOL_UNARY_NOT), A65_TOKEN_SYMBOL_UNARY_NOT),
	};

#define A65_TOKEN_SYMBOL_ID(_STRING__) \
	A65_TOKEN_SYMBOL_MAP.find(_STRING_)->second

#define IS_A65_TOKEN_SYMBOL(_STRING_) \
	(A65_TOKEN_SYMBOL_MAP.find(_STRING_) != A65_TOKEN_SYMBOL_MAP.end())

a65_token::a65_token(
	__in_opt int type,
	__in_opt int subtype,
	__in_opt int mode
	) :
		m_id(A65_UUID_INVALID),
		m_line(0),
		m_mode(mode),
		m_scalar(0),
		m_subtype(subtype),
		m_type(type)
{
	A65_DEBUG_ENTRY_INFO("Type=%u(%s), Subtype=%u(%x), Mode=%u(%x)", type, A65_TOKEN_STRING(type), subtype, subtype, mode, mode);

	generate();

	A65_DEBUG_EXIT();
}

a65_token::a65_token(
	__in const a65_token &other
	) :
		m_id(other.m_id),
		m_line(other.m_line),
		m_literal(other.m_literal),
		m_mode(other.m_mode),
		m_path(other.m_path),
		m_scalar(other.m_scalar),
		m_subtype(other.m_subtype),
		m_type(other.m_type)
{
	A65_DEBUG_ENTRY();

	increment();

	A65_DEBUG_EXIT();
}

a65_token::~a65_token(void)
{
	A65_DEBUG_ENTRY();

	decrement();

	A65_DEBUG_EXIT();
}

a65_token &
a65_token::operator=(
	__in const a65_token &other
	)
{
	A65_DEBUG_ENTRY();

	if(this != &other) {
		decrement();
		m_id = other.m_id;
		m_line = other.m_line;
		m_literal = other.m_literal;
		m_mode = other.m_mode;
		m_path = other.m_path;
		m_scalar = other.m_scalar;
		m_subtype = other.m_subtype;
		m_type = other.m_type;
		increment();
	}

	A65_DEBUG_EXIT();
	return *this;
}

void
a65_token::decrement(void)
{
	A65_DEBUG_ENTRY();

	a65_uuid &instance = a65_uuid::instance();
	if(instance.contains(m_id)) {
		instance.decrement(m_id);
	}

	A65_DEBUG_EXIT();
}

void
a65_token::generate(void)
{
	A65_DEBUG_ENTRY();

	m_id = a65_uuid::instance().generate();

	A65_DEBUG_EXIT();
}

a65_uuid_t
a65_token::id(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u(%x)", m_id, m_id);
	return m_id;
}

void
a65_token::increment(void)
{
	A65_DEBUG_ENTRY();

	a65_uuid &instance = a65_uuid::instance();
	if(instance.contains(m_id)) {
		instance.increment(m_id);
	}

	A65_DEBUG_EXIT();
}

size_t
a65_token::line(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u", m_line);
	return m_line;
}

a65_literal_t
a65_token::literal(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result[%u]=%p", m_literal.size(), &m_literal);
	return m_literal;
}

bool
a65_token::match(
	__in int type,
	__in_opt int subtype,
	__in_opt int mode
	) const
{
	bool result;

	A65_DEBUG_ENTRY_INFO("Type=%u(%s), Subtype=%u(%x), Mode=%u(%x)", type, A65_TOKEN_STRING(type), subtype, subtype, mode, mode);

	result = (type == m_type);
	if(result && (subtype != A65_TOKEN_SUBTYPE_UNDEFINED)) {

		result = (subtype == m_subtype);
		if(result && (mode != A65_TOKEN_MODE_UNDEFINED)) {
			result = (mode == m_mode);
		}
	}

	A65_DEBUG_EXIT_INFO("Result=%x", result);
	return result;
}

int
a65_token::mode(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u(%x)", m_mode, m_mode);
	return m_mode;
}

std::string
a65_token::path(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result[%u]=%s", m_path.size(), A65_STRING_CHECK(m_path));
	return m_path;
}

uint16_t
a65_token::scalar(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u(%04x)", m_scalar, m_scalar);
	return m_scalar;
}

void
a65_token::set(
	__in int type,
	__in_opt int subtype,
	__in_opt int mode
	)
{
	A65_DEBUG_ENTRY_INFO("Type=%u(%s), Subtype=%u(%x), Mode=%u(%x)", type, A65_TOKEN_STRING(type), subtype, subtype, mode, mode);

	m_mode = mode;
	m_subtype = subtype;
	m_type = type;

	A65_DEBUG_EXIT();
}

void
a65_token::set_literal(
	__in const a65_literal_t &literal
	)
{
	A65_DEBUG_ENTRY_INFO("Literal[%u]=%p", literal.size(), &literal);

	m_literal = literal;

	A65_DEBUG_EXIT();
}

void
a65_token::set_metadata(
	__in const std::string &path,
	__in size_t line
	)
{
	A65_DEBUG_ENTRY_INFO("Path[%u]=%s, Line=%u", path.size(), A65_STRING_CHECK(path), line);

	m_line = line;
	m_path = path;

	A65_DEBUG_EXIT();
}

void
a65_token::set_scalar(
	__in uint16_t scalar
	)
{
	A65_DEBUG_ENTRY_INFO("Scalar=%u(%04x)", scalar, scalar);

	m_scalar = scalar;

	A65_DEBUG_EXIT();
}

int
a65_token::subtype(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u(%x)", m_subtype, m_subtype);
	return m_subtype;
}

std::string
a65_token::to_string(void) const
{
	std::stringstream result;

	A65_DEBUG_ENTRY();

	result << "{" << A65_STRING_HEX(a65_uuid_t, m_id) << "} [" << A65_TOKEN_STRING(m_type) << "]";

	switch(m_type) {
		case A65_TOKEN_BEGIN:
		case A65_TOKEN_END:
			break;
		case A65_TOKEN_IDENTIFIER:
		case A65_TOKEN_LABEL:
		case A65_TOKEN_LITERAL:
			result << " [" << m_literal.size() << "]" << A65_STRING_CHECK(std::string(m_literal.begin(), m_literal.end()));
			break;
		case A65_TOKEN_SCALAR:
			result << " " << m_scalar << "(" << A65_STRING_HEX(uint16_t, m_scalar) << ")";
			break;
		default:
			break;
	}

	if(m_subtype != A65_TOKEN_SUBTYPE_UNDEFINED) {

		switch(m_type) {
			case A65_TOKEN_COMMAND:
				result << " " << A65_TOKEN_COMMAND_STRING(m_subtype);

				if(m_mode != A65_TOKEN_MODE_UNDEFINED) {
					result << " " << A65_TOKEN_COMMAND_MODE_STRING(m_mode);
				}
				break;
			case A65_TOKEN_CONSTANT:
				result << " " << A65_TOKEN_CONSTANT_STRING(m_subtype);
				break;
			case A65_TOKEN_DIRECTIVE:
				result << " " << A65_TOKEN_DIRECTIVE_STRING(m_subtype);
				break;
			case A65_TOKEN_MACRO:
				result << " " << A65_TOKEN_MACRO_STRING(m_subtype);
				break;
			case A65_TOKEN_PRAGMA:
				result << " " << A65_TOKEN_PRAGMA_STRING(m_subtype);
				break;
			case A65_TOKEN_REGISTER:
				result << " " << A65_TOKEN_REGISTER_STRING(m_subtype);
				break;
			case A65_TOKEN_SYMBOL:
				result << " " << A65_TOKEN_SYMBOL_STRING(m_subtype);
				break;
			default:
				break;
		}
	}

	result << " (" << A65_STRING_CHECK(m_path) << ":" << m_line << ")";

	A65_DEBUG_EXIT();
	return result.str();
}

int
a65_token::type(void) const
{
	A65_DEBUG_ENTRY();
	A65_DEBUG_EXIT_INFO("Result=%u(%x)", m_type, m_type);
	return m_type;
}
